{"version":3,"sources":["../src/signMessage.js"],"names":["bippath","MAX_SCRIPT_BLOCK","signMessage","transport","path","messageHex","paths","fromString","toPathArray","message","Buffer","from","offset","length","maxChunkSize","chunkSize","buffer","alloc","forEach","element","index","writeUInt32BE","writeUInt16BE","copy","send","res","v","r","slice","toString","s"],"mappings":"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","sourcesContent":["// @flow\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\n\nexport async function signMessage(\n  transport: Transport<*>,\n  { path, messageHex }: { path: string, messageHex: string }\n): Promise<{\n  v: number,\n  r: string,\n  s: string,\n}> {\n  const paths = bippath.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n\n  let offset = 0;\n  while (offset !== message.length) {\n    let maxChunkSize =\n      offset === 0\n        ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4\n        : MAX_SCRIPT_BLOCK;\n    let chunkSize =\n      offset + maxChunkSize > message.length\n        ? message.length - offset\n        : maxChunkSize;\n    const buffer = Buffer.alloc(\n      offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize\n    );\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(\n        buffer,\n        1 + 4 * paths.length + 2,\n        offset,\n        offset + chunkSize\n      );\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n\n  const v = res[0] - 0x30;\n  let r = res.slice(4, 4 + res[3]);\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s = res.slice(offset, offset + res[offset - 1]);\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n  s = s.toString(\"hex\");\n\n  return { v, r, s };\n}\n"],"file":"signMessage.js"}