{"version":3,"sources":["../src/startUntrustedHashTransactionInput.js"],"names":["createVarint","MAX_SCRIPT_BLOCK","startUntrustedHashTransactionInputRaw","transport","newTransaction","firstRound","transactionData","bip143","overwinter","additionals","p2","includes","send","startUntrustedHashTransactionInput","transaction","inputs","useTrustedInputForSegwit","data","Buffer","concat","version","timestamp","alloc","nVersionGroupId","length","i","isDecred","input","prefix","inputValue","value","trustedInput","from","script","scriptBlocks","offset","push","sequence","blockSize","slice","scriptBlock"],"mappings":"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","sourcesContent":["// @flow\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\n\nexport function startUntrustedHashTransactionInputRaw(\n  transport: Transport<*>,\n  newTransaction: boolean,\n  firstRound: boolean,\n  transactionData: Buffer,\n  bip143?: boolean = false,\n  overwinter?: boolean = false,\n  additionals: Array<string> = []\n) {\n  const p2 = additionals.includes(\"cashaddr\")\n    ? 0x03\n    : bip143\n    ? additionals.includes(\"sapling\")\n      ? 0x05\n      : overwinter\n      ? 0x04\n      : 0x02\n    : 0x00;\n  return transport.send(\n    0xe0,\n    0x44,\n    firstRound ? 0x00 : 0x80,\n    newTransaction ? p2 : 0x80,\n    transactionData\n  );\n}\n\nexport async function startUntrustedHashTransactionInput(\n  transport: Transport<*>,\n  newTransaction: boolean,\n  transaction: Transaction,\n  inputs: Array<{ trustedInput: boolean, value: Buffer }>,\n  bip143?: boolean = false,\n  overwinter?: boolean = false,\n  additionals: Array<string> = [],\n  useTrustedInputForSegwit?: boolean = false\n) {\n  let data = Buffer.concat([\n    transaction.version,\n    transaction.timestamp || Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n  ]);\n\n  await startUntrustedHashTransactionInputRaw(\n    transport,\n    newTransaction,\n    true,\n    data,\n    bip143,\n    overwinter,\n    additionals\n  );\n\n  let i = 0;\n  const isDecred = additionals.includes(\"decred\");\n\n  for (let input of transaction.inputs) {\n    let prefix;\n    let inputValue = inputs[i].value;\n    if (bip143) {\n      if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputValue.length]);\n      } else {\n        prefix = Buffer.from([0x02]);\n      }\n    } else {\n      if (inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputs[i].value.length]);\n      } else {\n        prefix = Buffer.from([0x00]);\n      }\n    }\n    data = Buffer.concat([\n      prefix,\n      inputValue,\n      isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n      createVarint(input.script.length),\n    ]);\n\n    await startUntrustedHashTransactionInputRaw(\n      transport,\n      newTransaction,\n      false,\n      data,\n      bip143,\n      overwinter,\n      additionals\n    );\n\n    let scriptBlocks = [];\n    let offset = 0;\n\n    if (input.script.length === 0) {\n      scriptBlocks.push(input.sequence);\n    } else {\n      while (offset !== input.script.length) {\n        let blockSize =\n          input.script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : input.script.length - offset;\n        if (offset + blockSize !== input.script.length) {\n          scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([\n              input.script.slice(offset, offset + blockSize),\n              input.sequence,\n            ])\n          );\n        }\n        offset += blockSize;\n      }\n    }\n\n    for (let scriptBlock of scriptBlocks) {\n      await startUntrustedHashTransactionInputRaw(\n        transport,\n        newTransaction,\n        false,\n        scriptBlock,\n        bip143,\n        overwinter,\n        additionals\n      );\n    }\n\n    i++;\n  }\n}\n"],"file":"startUntrustedHashTransactionInput.js"}