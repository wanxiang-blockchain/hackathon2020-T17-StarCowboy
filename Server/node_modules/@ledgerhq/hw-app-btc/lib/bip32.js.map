{"version":3,"sources":["../src/bip32.js"],"names":["bip32asBuffer","path","paths","bippath","fromString","toPathArray","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE"],"mappings":";;;;;;;AAEA;;;;AAEO,SAASA,aAAT,CAAuBC,IAAvB,EAA6C;AAClD,QAAMC,KAAK,GAAG,CAACD,IAAD,GAAQ,EAAR,GAAaE,mBAAQC,UAAR,CAAmBH,IAAnB,EAAyBI,WAAzB,EAA3B;AACA,MAAIC,MAAM,GAAGC,MAAM,CAACC,KAAP,CAAa,IAAIN,KAAK,CAACO,MAAN,GAAe,CAAhC,CAAb;AACAH,EAAAA,MAAM,CAAC,CAAD,CAAN,GAAYJ,KAAK,CAACO,MAAlB;AACAP,EAAAA,KAAK,CAACQ,OAAN,CAAc,CAACC,OAAD,EAAUC,KAAV,KAAoB;AAChCN,IAAAA,MAAM,CAACO,aAAP,CAAqBF,OAArB,EAA8B,IAAI,IAAIC,KAAtC;AACD,GAFD;AAGA,SAAON,MAAP;AACD","sourcesContent":["// @flow\n\nimport bippath from \"bip32-path\";\n\nexport function bip32asBuffer(path: string): Buffer {\n  const paths = !path ? [] : bippath.fromString(path).toPathArray();\n  let buffer = Buffer.alloc(1 + paths.length * 4);\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n"],"file":"bip32.js"}