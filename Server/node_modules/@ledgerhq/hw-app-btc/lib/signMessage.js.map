{"version":3,"sources":["../src/signMessage.js"],"names":["signMessage","transport","path","messageHex","paths","bippath","fromString","toPathArray","message","Buffer","from","offset","length","maxChunkSize","MAX_SCRIPT_BLOCK","chunkSize","buffer","alloc","forEach","element","index","writeUInt32BE","writeUInt16BE","copy","send","res","v","r","slice","toString","s"],"mappings":"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","sourcesContent":["// @flow\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\n\nexport async function signMessage(\n  transport: Transport<*>,\n  { path, messageHex }: { path: string, messageHex: string }\n): Promise<{\n  v: number,\n  r: string,\n  s: string,\n}> {\n  const paths = bippath.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n\n  let offset = 0;\n  while (offset !== message.length) {\n    let maxChunkSize =\n      offset === 0\n        ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4\n        : MAX_SCRIPT_BLOCK;\n    let chunkSize =\n      offset + maxChunkSize > message.length\n        ? message.length - offset\n        : maxChunkSize;\n    const buffer = Buffer.alloc(\n      offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize\n    );\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(\n        buffer,\n        1 + 4 * paths.length + 2,\n        offset,\n        offset + chunkSize\n      );\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n\n  const v = res[0] - 0x30;\n  let r = res.slice(4, 4 + res[3]);\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s = res.slice(offset, offset + res[offset - 1]);\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n  s = s.toString(\"hex\");\n\n  return { v, r, s };\n}\n"],"file":"signMessage.js"}